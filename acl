# -*- mode: indented-text; tab-width: 4; indent-tabs-mode: nil -*-
# Thanks to https://github.com/Exim/exim/wiki/SimpleGreylisting
# Newcomers to exim (like me) should note in particular that warn is
# often used purely for its side-effects, when log_message is not set.

# This acl is a message acl, and needs to be required from the
# acl_smtp_rcpt in order to have the $local_part and
# $local_part_prefix variables defined.  Add this to the end of the
# acl_smtp_rcpt acl, before the final accept:
# require acl = disposable_aliases
#
# Or use the CHECK_RCPT_LOCAL_ACL_FILE macro supported by Debian exim4.

# Think of this acl as an up front screening rule for incoming messages.
# If the address is known to be a disposable alias which is disabled,
# it can be rejected.
# FIXME discard is an option for rcpt acls.


disposable_aliases:
    # Firstly, accept if it was generated locally or by authenticated
    # clients.  This is how users change their configurations and
    # query the state.
    accept hosts = :
    accept authenticated = *

    # Get the prefix, stem, and any numeric count part from the $local_part...
    # ...Strip the final stem off to get the prefix.
    warn set acl_m_local_part_prefix = ${sg{$local_part}{\N[.][^.]*$\N}{.}}
    # ...Strip the prefix off to get the stem
    warn set acl_m_local_part_stem = ${sg{$local_part}{\N^.*[.]\N}{}}
    # ...Strip the number (if present) from the prefix to get the prefix sans count
    warn set acl_m_local_part_prefix_sans = ${sg{$acl_m_local_part_prefix}{\N[.]([0-9]+[.])?$\N}{}}
    # ...Get the number (if present) from the prefix and decrement if not zero.
    # Else get zero.
    warn set acl_m_local_part_prefix_count = ${if match{$acl_m_local_part_prefix}{\N[.]([0-9]+)[.]$\N} {${eval10:$1-1}}{0}}

    # Find any known aliases matching the stem
    warn set acl_m_known_alias = ${lookup sqlite{DISP_ALIASES_DB \
        select count(*) from aliases \
        where stem = "${quote_sqlite:$acl_m_local_part_stem}"} \
        {$value}fail}

    # If the last lookup failed, log a warning and accept the message
    accept condition = ${if eq{$acl_m_known_alias}{fail}}
        log_message = "failed to lookup alias for $local_part"

    # If this prefix is not a known alias, don't try and reject it.
    accept condition = ${if eq{$acl_m_known_alias}{0}}
        log_message = "no alias matching stem of $local_part"

    # Get the number of counters for this prefix (without any number part).
    # This should be 0 or 1 (if the lookup succeeds).
    warn log_message = "handling disposable alias: $local_part"
        set acl_m_num_counters = ${lookup sqlite{DISP_ALIASES_DB \
        select count(*) from counters \
        where prefix = "${quote_sqlite:$acl_m_local_part_prefix_sans}" \
        and stem = "${quote_sqlite:$acl_m_local_part_stem}"} \
        {$value}fail}

    # Warn if the lookup fails, and pretend there is no counter.
    warn condition = ${if eq{$acl_m_num_counters}{fail}}
        set acl_m_num_counters = 0
        log_message = "failed to lookup number of counters for $local_part"

    # If there is no counter yet, then initialiase it to the precomputed counter,
    warn !condition = $acl_m_num_counters
        log_message = "first sighting of email to $local_part_prefix$local_part" 
        set acl_m_initialised = ${lookup sqlite{DISP_ALIASES_DB \
            insert or replace into counters (prefix, stem, counter) values \
            ("${quote_sqlite:$acl_m_local_part_prefix_sans}", "${quote_sqlite:$acl_m_local_part_stem}", $acl_m_local_part_prefix_count)} \
            {1}fail}

    # Accept it if something went wrong
    accept condition = ${if eq{$acl_m_initialised}{fail}}
        log_message = "failed initialising sqlite database counter for $local_part"

    # If there was no counter yet, deny it if it was zero
    deny !condition = $acl_m_num_counters
         !condition = $acl_m_local_part_prefix_count

    # ....and accept it otherwise.
    accept !condition = $acl_m_num_counters
        condition = $acl_m_local_part_prefix_count


    # If we get here the prefix (sans counts) has been seen before,
    # and has an initialised counter.  Get the value (which may be -1
    # if the counter is disabled).
    warn set acl_m_counter = ${lookup sqlite{DISP_ALIASES_DB \
        select counter from counters \
        where prefix = "${quote_sqlite:$acl_m_local_part_prefix_sans}" \
        and stem = "${quote_sqlite:$acl_m_local_part_stem}"} \
        {$value}{fail}}

    # Warn if the lookup failed.
    warn condition = ${if eq{$acl_m_counter}{fail}}
        log_message = "failed to lookup sqlite database counter for $local_part"

    # If the counter is greater than zero, decrement the counter and
    # accept the message.
    accept condition = ${if > {$acl_m_counter}{0}}
	    condition = ${lookup sqlite{DISP_ALIASES_DB \
	        update counters \
            set counter = counter - 1 \
	        where prefix = "${quote_sqlite:$acl_m_local_part_prefix_sans}" \
	        and stem = "${quote_sqlite:$acl_m_local_part_stem}"}}

    # If the counter is greater then zero here, something went wrong
    # with the last step.  Log a warning and accept it.
    accept condition = ${if > {$acl_m_counter}{0}}
        log_message = "failed to decrement the counter for $local_part"

    # If we get here, and the prefix has a counter below zero,
    # it means it is disabled and we should always accept.
    accept condition = ${if < {$acl_m_counter}{0}}
        log_message = "unconditional delivery to $local_part"

    # Otherwise the counter is zero we deny it.
    deny message = "no more mail to $local_part allowed"
         log_message = "no more mail to $local_part allowed"


