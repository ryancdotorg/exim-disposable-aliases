
### router/600_local-config_disposable_aliases
#################################

#------------------

# supplementary aliases which allow arbitrary prefixes, delimited with a '.'
# delivery or rejection is controlled by a sqlite database lookup

# put this in a filter file
# if an alias is not defined, go to next router

# acl
# if the prefix is unseen
#   if it contains a count > 0
#     initialise sqlite to that many-1
#     accept # accept by default
#   else
#     initialise to 0 # reject by default
#     fail # or lookup default failure mode?
#   end
# else # it is known
#   if sqlite lookup count > 0
#     decrement count
#     allow
#   else if sqlite lookup count < 0
#     allow
#   else
#     fail # or lookup default failure mode?
#   end
# end
#     
# 


#

system_aliases:
  debug_print = "R: disposable_aliases for $local_part@$domain"
  driver = redirect
  domains = +local_domains
  allow_filter
  allow_fail
  allow_defer
  ignore_enotdir
  require_files = DISP_ALIASES_DB
  data = 
  local_part_prefix = *.
  
  ${lookup sqlite {/some/thing/sqlitedb \
  select name from aliases where id='userx';}}


  if <an alias is defined>
  if <it contains a count>
  and <sqlite count is ok>
  data = accept
  else
  data = <sqlite lookup of failure mode>
  # get the data parameter from sqlite
  data = sqlite;/some/thing/sqlitedb \
   select * from relays where ip='${quote_sqlite:$sender_host_address}';

  .ifdef SYSTEM_ALIASES_USER
  user = SYSTEM_ALIASES_USER
  .endif
  .ifdef SYSTEM_ALIASES_GROUP
  group = SYSTEM_ALIASES_GROUP
  .endif
  .ifdef SYSTEM_ALIASES_FILE_TRANSPORT
  file_transport = SYSTEM_ALIASES_FILE_TRANSPORT
  .endif
  .ifdef SYSTEM_ALIASES_PIPE_TRANSPORT
  pipe_transport = SYSTEM_ALIASES_PIPE_TRANSPORT
  .endif
  .ifdef SYSTEM_ALIASES_DIRECTORY_TRANSPORT
  directory_transport = SYSTEM_ALIASES_DIRECTORY_TRANSPORT
  .endif



# ------------------
# This router handles forwarding using traditional .forward files in users'
# home directories. It also allows mail filtering with a forward file
# starting with the string "# Exim filter" or "# Sieve filter".
#
# The no_verify setting means that this router is skipped when Exim is
# verifying addresses. Similarly, no_expn means that this router is skipped if
# Exim is processing an EXPN command.
#
# The check_ancestor option means that if the forward file generates an
# address that is an ancestor of the current one, the current one gets
# passed on instead. This covers the case where A is aliased to B and B
# has a .forward file pointing to A.
#
# The four transports specified at the end are those that are used when
# forwarding generates a direct delivery to a directory, or a file, or to a
# pipe, or sets up an auto-reply, respectively.
#
disposable_filter:
  debug_print = "R: disposable_aliases for $local_part@$domain"
  driver = redirect
  domains = +local_domains
#  check_local_user
  local_part_prefix = *.
  file = /etc/exim4/forward.disposable
  require_files = /etc/exim4/forward.disposable
  condition = ${if ${lookup{lc:$local_part}lsearch{/etc/exim4/disposable_aliases}}}
  no_verify
  no_expn
  check_ancestor
  allow_filter
  forbid_smtp_code = true
  directory_transport = address_directory
  file_transport = address_file
  pipe_transport = address_pipe
  reply_transport = address_reply
  skip_syntax_errors
  syntax_errors_to = root
  syntax_errors_text = \
    This is an automatically generated message. An error has\n\
    been found in your .forward file. Details of the error are\n\
    reported below. While this error persists, you will receive\n\
    a copy of this message for every message that is addressed\n\
    to you. If your .forward file is a filter file, or if it is\n\
    a non-filter file containing no valid forwarding addresses,\n\
    a copy of each incoming message will be put in your normal\n\
    mailbox. If a non-filter file contains at least one valid\n\
    forwarding address, forwarding to the valid addresses will\n\
    happen, and those will be the only deliveries that occur.

